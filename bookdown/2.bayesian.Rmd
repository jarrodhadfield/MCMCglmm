# Bayesian Analysis and MCMC {#bayesian}

In this Chapter I cover the basics of Bayesian analysis and Markov chain Monte Carlo (MCMC) techniques. Exposure to these ideas, and statistics in general, has increased dramatically since these notes were first written. Many readers may therefore wish to skip straight to later chapters that cover $\texttt{MCMCglmm}$ more specifically. 

## Introduction

There are fundamental differences between frequentist and Bayesian approaches, but for those of us interested in applied statistics the hope is that these differences do not translate into practical differences, and this is often the case. My advice would be *if* you can fit the same model using different packages and/or methods do so, and if they give very different answers worry. In some cases differences will exist, and it is important to know why, and which method is more appropriate for the data in hand.

In the context of a generalised linear mixed model (GLMM), here are what I see as the pro's and cons of using (restricted) maximum likelihood (REML) versus Bayesian MCMC methods. REML is fast and easy to use, whereas MCMC can be slow and technically more challenging. Particularly challenging is the specification of a sensible prior, something which is a non-issue in a REML analysis. However, analytical results for non-Gaussian GLMM are generally not available, and REML based procedures use approximate likelihood methods that may not work well. MCMC is also an approximation but the accuracy of the approximation increases the longer the analysis is run for, being exact at the limit. In addition, REML uses large-sample theory to derive approximate confidence intervals that may have very poor coverage, especially for variance components. Again, MCMC measures of confidence are exact, up to Monte Carlo error, and provide an easy and intuitive way of obtaining measures of confidence on derived statistics such as ratios of variances, correlations and predictions.

To illustrate the differences between the approaches let's imagine we've observed several draws (stored in the vector ${\bf y}$) from a standard normal (i.e. $\mu=0$ and $\sigma^{2}=1$). The likelihood is the probability of the data given the parameters:

$$Pr({\bf y} | \mu, \sigma^{2})$$

This is a conditional distribution, where the conditioning is on the model parameters which are taken as fixed and known. In a way this is quite odd because we've already observed the data, and we don't know what the parameter values are. In a Bayesian analysis we evaluate the conditional probability of the model parameters given the observed data:

$$Pr(\mu, \sigma^{2} | {\bf y})
\label{post1-eq}   (\#eq:post1-eq)$$

which seems more reasonable, until we realise that this probability is proportional to

$$Pr({\bf y} | \mu, \sigma^{2})Pr(\mu, \sigma^{2})$$

where the first term is the likelihood, and the second term represents our prior belief in the values that the model parameters could take. Because the choice of prior is rarely justified by an objective quantification of the state of knowledge it has come under criticism, and indeed we will see later that the choice of prior can make a difference.

## Likelihood

``` {r echo=FALSE}
set.seed(17)
```

We can generate 5 observations from this distribution using `rnorm`:

``` {r echo=TRUE}
Ndata<-data.frame(y=rnorm(5, mean=0, sd=1))
Ndata$y
```

We can plot the probability density function for the standard normal using `dnorm` and we can then place the 5 data on it:

``` {r label=dnorm, echo=TRUE, include=TRUE, fig.cap="Probability density function for the unit normal with the data points overlaid", tidy=FALSE}
possible.y<-seq(-3,3,0.1)                    # possible values of y
Probability<-dnorm(possible.y, mean=0, sd=1) # density of possible values 
plot(Probability~possible.y, type="l", ylab="Density", xlab="y")
Probability.y<-dnorm(Ndata$y, mean=0, sd=1)  # density of actual values
points(Probability.y~Ndata$y)
```

The likelihood of these data, conditioning on $\mu=0$ and $\sigma^2=1$, is proportional to the product of the densities (read off the y-axis on Figure \@ref(fig:dnorm)):

``` {r echo=TRUE}
prod(dnorm(Ndata$y, mean=0, sd=1))
```

Of course we don't know the true mean and variance and so we may want to ask how probable the data would be if, say, $\mu=0$, and $\sigma^2=0.5$:

``` {r echo=TRUE, eval=TRUE}
prod(dnorm(Ndata$y, mean=0, sd=sqrt(0.5)))
```

It would seem that the data are more likely under this set of parameters than the true parameters, which we must expect some of the time just from random sampling. To get some idea as to why this might be the case we can overlay the two densities (Figure \@ref(fig:dnorm1)), and we can see that although some data points (e.g. `r round(Ndata$y[which.max(dnorm(Ndata$y, mean=0, sd=1)-dnorm(Ndata$y, mean=0, sd=sqrt(0.5)))],3)`) are more likely with the true parameters, in aggregate the new parameters produce a higher likelihood.

``` {r label=dnorm1, echo=FALSE, include=TRUE, fig.cap="Two probability density functions for normal distributions with means of zero, and a variance of one (black line) and a variance of 0.5 (red line).  The data points are overlaid."}
pos.y<-seq(-3,3,0.1)
plot(dnorm(pos.y, mean=0, sd=1)~pos.y, type="l", ylim=c(0,max(dnorm(0, mean=0, sd=sqrt(0.5)))), ylab="Density", xlab="y")
points(Ndata$y, dnorm(Ndata$y, mean=0, sd=1))
lines(dnorm(pos.y, mean=0, sd=sqrt(0.5))~pos.y, type="l", col="red")
points(Ndata$y, dnorm(Ndata$y, mean=0, sd=sqrt(0.5)), col="red")
```

The likelihood of the data can be calculated on a grid of possible parameter values to produce a likelihood surface, as in Figure \@ref(fig:Lsurface). The densities on the contours have been scaled so they are relative to the density of the parameter values that have the highest density (the maximum likelihood estimate of the two parameters). Two things are apparent. First, although the surface is symmetric about the line $\mu = \hat{\mu}$ (where $\hat{}$ stands for maximum likelihood estimate) the surface is far from symmetric about the line $\sigma^{2} = \hat{\sigma}^{2}$. Second, there are a large range of parameter values for which the data are only 10 times less likely than if the data were generated under the maximum likelihood estimates.

``` {r echo=FALSE}
lik<-function(par, y, log=FALSE){
   if(log){
     l<-sum(dnorm(y, mean=par[1], sd=sqrt(par[2]), log=TRUE))
   }else{
     l<-prod(dnorm(y, mean=par[1], sd=sqrt(par[2])))
   }
   return(l)
} 
mu<-seq(-2,2,length=100)
sigma2<-seq(0.0001,5,length=100)
L<-matrix(0,100,100)

for(i in 1:100){
   for(j in 1:100){
      L[i,j]<-lik(c(mu[i], sigma2[j]), y=Ndata$y)
   }
}
```

``` {r label=Lsurface, echo=FALSE, include=TRUE, fig.cap="Likelihood surface for the likelihood $Pr({\\bf y}|\\mu, \\sigma^{2})$. The likelihood has been normalised so that the maximum likelihood has a value of one."}
par(mar=c(5, 4.5, 4, 2)+0.1)
contour(mu,sigma2,L/max(L), xlab=expression(mu), ylab=expression(sigma^2), cex.lab=1.25, nlevels=15, mar=c(5, 4.5, 4, 2)+0.1)
```

### Maximum Likelihood (ML)

The ML estimator is the combination of $\mu$ and $\sigma^{2}$ that make the data most likely. Although we could evaluate the density on a grid of parameter values (as we did to produce Figure \@ref(fig:Lsurface)) in order to locate the maximum, for such a simple problem the ML estimator can be derived analytically. However, so we don't have to meet some nasty maths later, I'll introduce and use one of R's generic optimising routines that can be used to maximise the likelihood function (in practice, the log-likelihood is maximised to avoid numerical problems):

``` {r ML-est}
lik<-function(par, y, log=FALSE){
   if(log){
     l<-sum(dnorm(y, mean=par[1], sd=sqrt(par[2]), log=TRUE))
   }else{
     l<-prod(dnorm(y, mean=par[1], sd=sqrt(par[2])))
   }
   return(l)
}   
# function which takes the parameter vector (mean and *variance*) and the data and returns the (log) likelihood

MLest<-optim(c(mean=0,var=1), fn=lik, y=Ndata$y, log=TRUE, control = list(fnscale = -1,reltol=1e-16))$par
```

The first call to `optim` are starting values for the optimisation algorithm, and the second argument (`fn`) is the function to be maximised. By default `optim` will try to minimise the function hence multiplying by -1 (`fnscale = -1`). The algorithm has successfully found
the mode:

``` {r echo=TRUE}
MLest
```

Alternatively we could also fit the model using `glm`, which by default assumes the response is normal:

``` {r echo=TRUE}
m1a.1<-glm(y~1, data=Ndata)
summary(m1a.1)
```

Here we see that although the estimate of the mean (intercept) is the same, the estimate of the variance (the dispersion parameter:
`r formatC(summary(m1a.1)$dispersion, 3, format="f")`) is higher when fitting the model using `glm`. In fact the ML estimate is a factor $\frac{n}{n-1}$ smaller because the `glm` estimate has used Bessel's correction: 

``` {r echo=TRUE}
MLest["var"]*(5/4)
```

### Restricted Maximum Likelihood (REML)

Why do we use Bessel's correction? Imagine we had only observed the first two values of ${\bf y}$ (Figure \@ref(fig:muvar)). The variance is defined as the average squared distance between a random variable and the *true* mean. However, the ML estimator of the variance is the average squared distance between the random variable and the ML *estimate* of the mean. Since the ML estimator of the mean is the average of the two numbers (the dashed line) then the average squared distance will always be smaller than if the true mean was used, unless the ML estimate of the mean and the true mean coincide. This is why we use Bessel's $n-1$ correction when estimating the variance from the sum of squares, or why we divide by $n-n_p$ when estimating the residual variance in a liner model with $n_p$ parameters, or more generally why we use REML in linear mixed models. Why these corrections for uncertainty in the mean, or model parameters, have this form can be understood from a Bayesian perspective (see Section \@ref(Vprior-sec)). 

``` {r label=muvar, echo=FALSE, include=TRUE, fig.cap="Probability density function for the unit normal with two realisations overlaid. The solid vertical line is the true mean, whereas the vertical dashed line is the mean of the two realisations (the ML estimator of the mean). The variance is the expected squared distance between the true mean and the realisations. The ML estimator of the variance is the average squared distance between the ML mean and the realisations (horizontal dashed lines), which is always smaller than the average squared distance between the true mean and the realisations (horizontal solid lines)"}
y2<-Ndata$y[c(1,5)]
plot(dnorm(pos.y)~pos.y, type="l", ylab="Density", xlab="y")
abline(v=0)

points(y2, dnorm(y2))
lines(c(y2[1],0), c(dnorm(y2[1]),dnorm(y2[1]))+0.01)
lines(c(y2[2],0), c(dnorm(y2[2]),dnorm(y2[2]))+0.01)
text(y2[1], dnorm(y2[1])+0.02, label=bquote(.(round(y2[1],3)) ^2 *"="* .(round((y2[1])^2,3))), pos=2)
text(y2[2], dnorm(y2[2])+0.02, label=bquote(.(round(y2[2],3)) ^2 *"="* .(round((y2[2])^2,3))), pos=4)

abline(v=mean(y2), lty=2)
lines(c(y2[1],mean(y2)), c(dnorm(y2[1],0),dnorm(y2[1],0))-0.01, lty=2)
lines(c(y2[2],mean(y2)), c(dnorm(y2[2],0),dnorm(y2[2],0))-0.01, lty=2)
text(y2[1], dnorm(y2[1])-0.02, label=bquote(.(round(y2[1]-mean(y2),3)) ^2 *"="* .(round((y2[1]-mean(y2))^2,3))), pos=2, col="darkgrey")
text(y2[2], dnorm(y2[2])-0.02, label=bquote(.(round(y2[2]-mean(y2),3)) ^2 *"="* .(round((y2[2]-mean(y2))^2,3))), pos=4, col="darkgrey")
```

## Prior Distribution 

$\texttt{MCMCglmm}$ uses a normal prior for the fixed effects and an inverse-Wishart prior for the residual variance. In the current model their is a single fixed effect ($\mu$) and a scalar (residual) variance ($\sigma^2$). For the mean we will use the default prior - a diffuse normal centred around zero but with very large variance ($10^{8}$). For the residual variance, the inverse-Wishart prior takes two scalar parameters. In $\texttt{MCMCglmm}$ this is parameterised through the parameters $\texttt{V}$ and $\texttt{nu}$. The distribution tends to a point mass on $\texttt{V}$ as the degree of belief parameter, $\texttt{nu}$ goes to infinity. We will defer a full discussion of the inverse-Wishart prior to Section \@ref(Vprior-sec) and for now we will use the prior specification $\texttt{V}=1$ and $\texttt{nu}=0.002$ which used to be frequently used for variances. As before, we can evaluate and plot the density function in order to visualise what the distribution looks like (Figure \@ref(fig:dinvgamma1)).


``` {r label=dinvgamma1, echo=FALSE, include=TRUE, fig.cap="Probability density function for a univariate inverse-Wishart with the variance at the limit set to 1 ($\\texttt{V}=1$) and a degree of belief parameter set to 0.002 ($\\texttt{nu}=0.002$)."}
xv<-seq(1e-16,5,length=1000)
plot(I(dgamma(1/xv, shape=0.002/2, rate=(0.002)/2)/(xv^2))~xv, xlab=expression(sigma^2), ylab="Density", cex.lab=1.25, type="l")
```

As before we can write a function for calculating the (log) prior probability:

``` {r prior-p, echo=TRUE}
prior.p<-function(par, priorB, priorR, log=FALSE){
    if(log){
      d<-dnorm(par[1], mean=priorB$mu, sd=sqrt(priorB$V), log=TRUE)+dgamma(1/par[2],shape=priorR$nu/2, rate=(priorR$nu*priorR$V)/2, log=TRUE)-2*log(par[2])
    }else{
      d<-dnorm(par[1], mean=priorB$mu, sd=sqrt(priorB$V))*dgamma(1/par[2],shape=priorR$nu/2, rate=(priorR$nu*priorR$V)/2)/par[2]^2
    } 
    return(d) 
}
```

where `priorR` is a list with elements `V` and `nu` specifying the prior for the variance, and `priorB` is a list with elements `mu` and `V` specifying the prior for the mean. $\texttt{MCMCglmm}$ takes these prior specifications as a list:

``` {r echo=TRUE}
prior<-list(R=list(V=1, nu=0.002), B=list(mu=0, V=1e+8))
```

## Posterior Distribution

By multiplying the likelihood by the prior probability for that set of parameters we can get the posterior probability up to a proportional constant. We can write a function for doing this:

``` {r likprior, echo=TRUE}
likprior<-function(par, y, priorB, priorR, log=FALSE){

 if(log){
   pd<-lik(par,y, log=TRUE)+prior.p(par,priorB=priorB,priorR=priorR, log=TRUE)
 }else{
   pd<-lik(par,y)*prior.p(par,priorB=priorB,priorR=priorR)
 } 
 return(pd)
}
```

and we can overlay the posterior density (scaled by the posterior density at the posterior mode) on the likelihood surface we calculated before (Figure \@ref(fig:Lsurface)).

``` {r echo=FALSE}
P<-matrix(0,100,100)
for(i in 1:100){
   for(j in 1:100){
      P[i,j]<-likprior(c(mu[i], sigma2[j]), y=Ndata$y, priorB=prior$B, priorR=prior$R)
   }
}
```

``` {r label=Psurface, echo=FALSE, fig=TRUE, include=TRUE, fig.cap="Likelihood surface for the likelihood $Pr({\\bf y}|\\mu, \\sigma^{2})$ in black, and the posterior distribution $Pr(\\mu, \\sigma^{2} | {\\bf y})$ in red.  The likelihood has been normalised so that the maximum likelihood has a value of one, and the posterior distribution has been normalised so that the posterior mode has a value of one. The prior distributions  $Pr(\\mu)\\sim N(0, 10^8)$ and  $Pr(\\sigma^{2})\\sim IW(\\texttt{V}=1, \\texttt{nu}=0.002)$ were used."}
par(mar=c(5, 4.5, 4, 2)+0.1)
contour(mu,sigma2, L/max(L), xlab=expression(mu), ylab=expression(sigma^2), cex.lab=1.25, nlevels=15)
contour(mu,sigma2, P/max(P), add=TRUE, nlevels=15, col="red", drawlabels = FALSE)
```

The prior has some influence on the posterior mode of the variance, and we can use an optimisation algorithm again to locate the mode:

``` {r echo=TRUE}
Best<-optim(c(mean=0,var=1), fn=likprior, y=Ndata$y, priorB=prior$B, priorR=prior$R, log=TRUE, method="L-BFGS-B", lower=c(-1e+5, 1e-5), upper=c(1e+5,1e+5), control = list(fnscale = -1, factr=1e-16))$par
Best
```

The posterior mode for the mean is essentially identical to the ML estimate, but the posterior mode for the variance is even less than the ML estimate, which is known to be downwardly biased. The reason that the ML estimate is downwardly biased is because it did not take into account the uncertainty in the mean, as we saw when discussing the motivation behind REML. In a Bayesian analysis we can do this by evaluating the marginal distribution of $\sigma^{2}$ by averaging over the uncertainty in the mean. Before we do this, however, it will be instructive to see why this would be hard using our function that simply multiplies the likelihood by the prior (`likprior`). This function (the probabilities on the right-hand side) is only *proprtional* to the posterior density (the left-hand side), not equal to it, implying 

$$Pr(\mu, \sigma^{2} | {\bf y}) = \frac{1}{C} Pr({\bf y} | \mu, \sigma^{2})Pr(\mu, \sigma^{2})$$

where $C$ is some constant. In some cases this is not an issue - when finding the posterior mode it was not an issue since the parameters that maximise the posterior density would also maximise the posterior density scaled by $C$. Similarly, if we wanted to make relative statements about posterior probabilities, then $C$ would cancel. For example, we can see how much more likely a variance of a half is versus a variance of one (assuming the mean is zero):

```{r }
p.0.5<-likprior(c(0,0.5), y=Ndata$y, priorB=prior$B, priorR=prior$R)
p.1.0<-likprior(c(0,1.0), y=Ndata$y, priorB=prior$B, priorR=prior$R)

p.0.5/p.1.0
```

However, in many instances we would like to work with the normalised posterior density, so how do we get $C$? Well we know that if we took the posterior probability of being any combination of $\mu$ and $\sigma^{2}$ it must be equal to one:

$$\int_{\sigma^2}\int_\mu Pr(\mu, \sigma^{2} | {\bf y})d\mu d\sigma^2=1$$

and so because

$$1 =\frac{1}{C}\int_{\sigma^2}\int_\mu Pr({\bf y} | \mu, \sigma^{2})Pr(\mu, \sigma^{2})d\mu d\sigma^2$$

we can integrate our parameters over `likprior` to get $C$. Not easy, and requires numerical integration:

```{r integral-C}
C<-adaptIntegrate(likprior, y=Ndata$y, priorR=prior$R, priorB=prior$B, lower=c(-Inf, 0), upper=c(Inf, Inf))$integral
```

The posterior density for $\mu=0$ and $\sigma^2=0.5$ is `p.0.5/C=``r round(p.0.5/C, 3)`. Neither interesting or particularly interpretable, and often we want to perform additional integration in order to compute quantities of interest. For example, imagine we wanted to know the probability that the parameters lay in the region of parameter space we were plotting, i.e. lay in the square $\mu = (-2,2)$ and $\sigma^{2} = (0,5)$. To obtain this probability we need to calculate the definite integral

$$\int_{\sigma^{2}=0}^{\sigma^{2}=5} \int_{\mu=-2}^{\mu=2} Pr(\mu, \sigma^{2} | {\bf y})d\mu d\sigma^2$$

which requires integrating our `likprior` over the same limits and rescaling by $C$:

```{r integral-cube}
p.square<-adaptIntegrate(likprior, y=Ndata$y, priorR=prior$R, priorB=prior$B, lower=c(-2, 0), upper=c(2,5))$integral
p.square/C
```

While this is doable for simple problems like this, numerical integration for high-dimensional problems is often not feasible and MCMC provides a viable alternative.

We can fit this model in $\texttt{MCMCglmm}$ pretty much in the same way as we did using `glm`:


``` {r m1a.2}
m1a.2<-MCMCglmm(y~1, data=Ndata, prior=prior, thin=1)
```

The Markov chain is drawing random (but often correlated) samples from the joint posterior distribution (depicted by the red contours in Figure \@ref(fig:Psurface)). The element of the output called `Sol` contains the posterior samples for the
mean, and the element called `VCV` contains the posterior samples for the variance. We can produce a scatter plot:

``` {r echo=TRUE, eval=FALSE}
points(cbind(m1a.2$Sol, m1a.2$VCV))
```

``` {r label=PsurfaceMCMC, echo=FALSE, include=TRUE, fig.cap="The posterior distribution $Pr(\\mu, \\sigma^{2} | {\\bf y})$. The black dots are samples from the posterior using MCMC, and the red contours are calculated by evaluating the posterior density on a grid of parameter values. The contours are normalised so that the posterior mode has a value of one."}
par(mar=c(5, 4.5, 4, 2)+0.1)
contour(mu,sigma2,P/max(P), nlevels=15, col="red", drawlabels = FALSE)
points(cbind(m1a.2$Sol, m1a.2$VCV), cex=0.2)
contour(mu,sigma2,P/max(P), nlevels=15, col="red", add=TRUE, drawlabels = FALSE)
```

and we see that MCMCglmm is sampling the same distribution as the posterior distribution calculated on a grid of possible parameter values (Figure \@ref(fig:PsurfaceMCMC)).

A very nice property of MCMC is that we can calculate probabilities from the output without having to explicitly perform integration. Earlier we calculated the probability that the mean lay between $\pm2$ and the variance was less than 5 ($\texttt{p.square/C}=$ `r round(p.square/C,3)`). Because MCMC has sampled the posterior distribution randomly, this probability will be equal to the expected probability that we have drawn an MCMC sample from the region. We can obtain an estimate of this by seeing what proportion of our actual samples lie in this square:


``` {r echo=TRUE}
prop.table(table(m1a.2$Sol>-2 & m1a.2$Sol<2 & m1a.2$VCV<5))
```

There is Monte Carlo error in the answer (`r formatC(prop.table(table(m1a.2$Sol>-2 & m1a.2$Sol<2 & m1a.2$VCV<5))[2], format="f",3)`) but if we collect a large number of samples then this can be minimised.

### Marginal Posterior Distribution

The marginal distribution is often of primary interest in statistical inference, because it represents our knowledge about a parameter given the data:

$$Pr(\sigma^{2} | {\bf y}) = \int Pr(\mu, \sigma^{2} | {\bf y})d\mu
\label{marg-eq}   (\#eq:marg-eq)$$

after averaging over any nuisance parameters, such as the mean in this case.

Using MCMC, we can obtain the marginal distribution of the variance by simply evaluating the draws in `VCV` ignoring (averaging over) the draws in `Sol`:

``` {r echo=TRUE, eval=FALSE}
hist(m1a.2$VCV)
abline(v=Best["var"], col="red")
```

``` {r label=MsurfaceMCMC, echo=FALSE, include=TRUE, fig=TRUE, fig.cap="Histogram of samples from the marginal distribution of the variance $Pr(\\sigma^{2} | {\\bf y})$ using MCMC. The vertical line is the joint posterior mode, which differs slightly from the marginal posterior mode (the peak of the marginal distribution)."}
hist(m1a.2$VCV[which(m1a.2$VCV<5)], breaks=50, main=expression(paste("Posterior Distribution of ",  sigma^2)), xlab=expression(sigma^2))
abline(v=Best["var"], col="red")
```

In this example the marginal mode and the joint mode are very similar, although this is not necessarily the case and can depend on both the data and the prior. Section \@ref(Vprior-sec) covers properties of the inverse-Wishart prior in detail. 

### Credible Intervals {#intervals-sec}



## MCMC {#MCMC}

In order to be confident that $\texttt{MCMCglmm}$ has successfully sampled the posterior distribution it will be necessary to have a basic understanding of how MCMC works. The aim of MCMC is to sample parameter values from their posterior distribution, shown exactly (up to proportionality) in Figure \@ref(fig:Psurface). In all but the very simplest cases this distribution is not of a known form and we cannot sample from it directly by using functions such as `rnorm`. However we can set up a random walk in parameter space such that the chance a walker visits a particular set of parameter values is proportional to their posterior density. Importantly, this can done without needing to normalise the posterior density by $C$. 

### Starting values

First we need to initialise the chain and specify a set of parameter values from which the chain can start moving through parameter space. In practice, it's generally a good idea to start the chain in region of relatively high probability. Although starting configurations can be set by the user using the `start` argument, in general the heuristic techniques used by $\texttt{MCMCglmm}$ seem to work quite well. We will denote the parameter values of the starting configuration (time $t=0$) as $\mu_{t=0}$ and ${\sigma^{2}}_{t=0}$. There are several ways in which we can get the chain to move in parameter space, and the main techniques used in $\texttt{MCMCglmm}$ are Gibbs sampling and Metropolis-Hastings updates. To illustrate, it will be easier to turn the contour plot of the posterior distribution into a perspective plot (Figure \@ref(fig:Psurface-persp)).

``` {r echo=FALSE}
P.new<-L
mu.new<-seq(Best[1]-1, Best[1]+1, length=100)
sigma2.new<-seq(max(Best[2]-1,0.00001), Best[2]+1, length=100)
for(i in 1:100){
for(j in 1:100){
P.new[i,j]<-likprior(c(mu.new[i], sigma2.new[j]), y=Ndata$y, priorB=prior$B, priorR=prior$R)
}}
P.new<-P.new/C
```

``` {r label=Psurface-persp, echo=FALSE, include=TRUE, fig=TRUE, fig.cap="The posterior distribution $Pr(\\mu, \\sigma^{2} | {\\bf y})$. This perspective plot is equivalent to the contour plot in Figure \\@ref(fig:Psurface) but it has been normalised by $C$ and is equal to, not just proportional to, the posterior density."}
par(bg="white")
persp(mu.new,sigma2.new, P.new, theta = 20, ltheta=60, phi = 30, lphi=0.3, expand = 0.5, col ="lightblue", shade=0.3, xlab="", ylab="", zlab="") 
text(-0.45,-0.11,"Pr")
text(-0.1,-0.35,expression(mu))
text(0.3,-0.2,expression(sigma^2))
```

### Metropolis-Hastings updates

After initialising the chain we need to decide where to go next, and this decision is based on two rules. First we have to generate a candidate destination, and then we need to decide whether to go there or stay where we are. There are many ways in which we could generate candidate parameter values, and $\texttt{MCMCglmm}$ uses a well tested and simple method. A random set of coordinates are picked from a multivariate normal distribution that is centred on the initial coordinates $\mu_{t=0}$ and $\sigma^{2}_{t=0}$. We will denote this new set of parameter values as $\mu_{new}$ and $\sigma^{2}_{new}$. The question then remains whether to move to this new set of parameter values or remain at our current parameter values now designated as old $\mu_{old}=\mu_{t=0}$ and $\sigma^{2}_{old}=\sigma^{2}_{t=0}$. If the posterior probability for the new set of parameter values is greater, then the chain moves to this new set of parameters and the chain has successfully completed an iteration: ($\mu_{t=1} = \mu_{new}$ and $\sigma^{2}_{t=1}=\sigma^{2}_{new}$). If the new set of parameter values has a lower posterior probability then the chain may move there, but not all the time. The probability that the chain moves to low lying areas, is determined by the relative difference between the old and new posterior probabilities. If the posterior probability for $\mu_{new}$ and $\sigma^{2}_{new}$ is 5 times less than the posterior probability for $\mu_{old}$ and $\sigma^{2}_{old}$, then the chain would move to the new set of parameter values 1 in 5 times. If the move is successful then we set $\mu_{t=1} = \mu_{new}$ and $\sigma^{2}_{t=1}=\sigma^{2}_{new}$ as before, and if the move is unsuccessful then the chain stays where it is ($\mu_{t=1} = \mu_{old}$ and $\sigma^{2}_{t=1}=\sigma^{2}_{old}$). Note that we only need to know the posterior density up to proportionality to make these calculations (i.e we could use `likprior` directly without knowing $C$).  Using these rules we can record where the chain has travelled and generate an approximation of the posterior distribution. Basically, a histogram of Figure \@ref(fig:Psurface-persp).

Why Metropolis-Hastings updates work can perhaps be more easily understood in terms of a simpler toy example. Imagine we had a strong prior such that only two sets of parameter values had positive posterior probability: Set A ($\mu_A$ an $\sigma^2_A$) with a posterior probability 5 times that of Set B. If the chain is currently at Set A then the candidate parameter values will be Set B and vice-versa. Since we move from Set A to Set B 20% of the time and we move from Set B to Set A 100% of the time, the odds of being in Set A versus Set B is 1:0.2 which is exactly equal to their posterior odds of 5:1.  

### Gibbs Sampling

Gibbs sampling is a special case of Metropolis-Hastings updating, and $\texttt{MCMCglmm}$ uses Gibbs sampling to update most parameters. In the Metropolis-Hastings example above, the Markov Chain was allowed to move in both directions of parameter space simultaneously. An equally valid approach would have been to set up two Metropolis-Hastings schemes where the chain was first allowed to move along the $\mu$ axis, and then along the $\sigma^{2}$ axis. In Figure \@ref(fig:Psurface-persp2) I have cut the posterior distribution of Figure \@ref(fig:Psurface-persp) in half, and the edge of the surface facing left is the conditional distribution of $\mu$ given that $\sigma^{2}=1$:

$$Pr(\mu |\sigma^{2}=1, \boldsymbol{\mathbf{y}}).$$

``` {r echo=FALSE}
P.new2<-L
mu.new<-seq(Best[1]-1, Best[1]+1, length=100)
sigma2.new2<-seq(1, Best[2]+2, length=100)
for(i in 1:100){
for(j in 1:100){
P.new2[i,j]<-likprior(c(mu.new[i], sigma2.new2[j]), y=Ndata$y, priorB=prior$B, priorR=prior$R)
}}
```

``` {r label=Psurface-persp2, echo=FALSE, include=TRUE, fig.cap="The posterior distribution $Pr(\\mu, \\sigma^{2} | {\\bf y})$, but only for values of $\\sigma^{2}$ between 1 and 5, rather than 0 to 5 (Figure \\@ref(fig:Psurface-persp). The edge of the surface facing left is the conditional distribution of the mean when $\\sigma^{2}=1$ ($Pr(\\mu | {\\bf y}, \\sigma^{2}=1)$). This conditional distribution follows a normal distribution."}
par(bg="white")
persp(mu.new,sigma2.new2, P.new2/max(P.new2), theta = 50, ltheta=90, phi = 20, lphi=80, expand = 0.5, col ="lightblue", shade=0.1, xlab="", ylab="", zlab="")
text(-0.402,0,"Pr")
text(-0.2,-0.3,expression(mu))
text(0.2,-0.3,expression(sigma^2))
```

If we were using Metropolis-Hastings updates to sample $\mu$ we would need to evaluate this density, which may be much simpler than evaluating the full density. In fact for some cases, the equation that describes this conditional distribution can be derived despite the equation for the complete joint distribution of Figure \@ref(fig:Psurface-persp) remaining unknown. When the conditional distribution of $\mu$ is known we can use Gibbs sampling. Lets say the chain at a particular iteration is located at $\sigma^{2}=1$. If we updated $\mu$ using a Metropolis-Hastings algorithm we would generate a candidate value and evaluate its relative probability compared to the old value. This procedure would take place in the slice of posterior facing left in Figure \@ref(fig:Psurface-persp2). However, because we know the actual equation for this slice we can just generate a new value of $\mu$ directly. This is Gibbs sampling. The slice of the posterior that we can see in Figure \@ref(fig:Psurface-persp2) actually has a normal distribution. Because of the weak prior this normal distribution has a mean close to the mean of $\bf{y}$ and a variance close to $\frac{\sigma^{2}}{n} = \frac{1}{n}$. Gibbs sampling can be much more efficient than Metropolis-Hastings updates, especially when high dimensional conditional distributions are known, as is typical in GLMMs. A technical description of the sampling schemes used by $\texttt{MCMCglmm}$ is given in the Chapter \@ref(#technical), but is perhaps not important to know.


### MCMC Diagnostics {#diagnostics-sec}

When fitting a model using $\texttt{MCMCglmm}$ the parameter values through which the Markov chain has travelled are stored and returned. The length of the chain (the number of iterations) can be specified using the `nitt` argument[^1.1] (the default is 13,000), and should be long enough so that the posterior approximation is valid. If we had known the joint posterior distribution in Figure \@ref(fig:Psurface-persp) we could have sampled directly from the posterior. If this had been the case, each successive value in the Markov chain would be independent of the previous value after conditioning on the data, ${\bf y}$, and a thousand iterations of the chain would have produced a histogram that resembled Figure \@ref(fig:Psurface-persp) very closely. However, generally we do not know the joint posterior distribution of the parameters, and for this reason the parameter values of the Markov chain at successive iterations are usually not independent and care needs to be taken regarding the validity of the approximation. $\texttt{MCMCglmm}$ returns the Markov chain as `mcmc` objects, which can be analysed using the `coda` package. The function `autocorr` from the package $\texttt{coda}$ reports the level of non-independence between successive samples in the chain:

``` {r echo=TRUE}
autocorr(m1a.2$Sol)
autocorr(m1a.2$VCV)
```

The correlation between successive samples is low for the mean (`r formatC(autocorr(m1a.2$Sol)[2], format="f", 3)`) but a bit high for the variance (`r formatC(autocorr(m1a.2$VCV)[2], format="f", 3)`). When auto-correlation is high we effectively have fewer samples from the posterior than we have saved. The function `effectiveSize`, also from $\texttt{coda}$, reports the *effective* number of samples saved - if the autocorrelation could be made zero this would be the number of samples required to give the same precision on the posterior mean.  For the variance, the effective sample size is `r round(effectiveSize(m1a.2$VCV))` quite a bit less than the number of stored posterior samples  `r nrow(m1a.2$VCV)`. When the effective sample size is low the chain needs to be run for longer, and this can lead to storage problems for high dimensional problems. The argument `thin` can be passed to $\texttt{MCMCglmm}$ specifying the intervals at which the Markov chain is stored. In model `m1a.2` we specified `thin=1` meaning we stored every iteration (the default is `thin=10`). I usually aim to store 1,000-2,000 effective posterior samples with the autocorrelation between successive *stored* samples less than 0.1.

The approximation obtained from the Markov chain is conditional on the set of parameter values that were used to initialise the chain. In many cases the first iterations show a strong dependence on the starting parametrisation, but as the chain progresses this dependence may be lost. As the dependence on the starting parametrisation diminishes the chain is said to converge and the argument `burnin` can be passed to `MCMCped` specifying the number of iterations which must pass before samples are stored. The default burn-in period is 3,000 iterations. Assessing convergence of the chain is notoriously difficult, but visual inspection and diagnostic tools such as `gelman.diag` often suffice. For difficult models, running several chains from different starting values and ensuring they have all converged on the same distribution is a good idea.

``` {r label=time-series, include=TRUE, fig.cap="Summary plot of the Markov Chain for the intercept.  The left plot is a trace of the sampled posterior, and can be thought of as a time-series.  The right plot is a density estimate, and can be thought of a smoothed histogram approximating the posterior."}
plot(m1a.2$Sol)
```

On the left of Figure \@ref(fig:time-series) is a time-series of the parameter as the MCMC iterates, and on the right is a posterior density estimate of the parameter (a smoothed histogram of the output). If the model has converged there should be no trend in the time-series. The equivalent plot for the variance is a little hard to see on the original scale, but on the log scale the chain looks good (Figure \@ref(fig:time-series2):

``` {r label=time-series2, include=TRUE, fig.cap="Summary plot of the Markov Chain for the logged variance. The logged variance was plotted rather than the variance because it was easier to visualise. The left plot is a trace of the sampled posterior, and can be thought of as a time-series.  The right plot is a density estimate, and can be thought of a smoothed histogram approximating the posterior."}
plot(log(m1a.2$VCV))
```

## Priors for Residual Variances  {#Vprior-sec}

$\texttt{MCMCglmm}$ uses an inverse-Wishart prior for the residual variance and so here will cover the properties of the scalar inverse-Wishart distribution and prior. Section \@ref(VCVprior-sec) can be consulted for inverse-Wishart covariance matrices. For random effect (co)variances it is possible to use scaled non-central $F$-distribution priors which is strongly recommended (see Section \@ref(PXprior-sec)). 

For a single variance, the inverse-Wishart prior is parameterised through the parameters $\texttt{V}$ and $\texttt{nu}$ in MCMCglmm. The MCMCglmm parameterisation of the inverse-Wishart is not standard but I find it intuitive: the prior information is equivalent to observing $\texttt{nu}$ residuals with variance $\texttt{V}$. Consequently, the distribution concentrates on $\texttt{V}$ as the degree of belief parameter, $\texttt{nu}$ increases. The distribution tends to be right skewed when $\texttt{nu}$ is not very large, with a mode of $\texttt{V}\frac{\texttt{nu}}{\texttt{nu}+2}$ but a mean of $\texttt{V}\frac{\texttt{nu}}{\texttt{nu}-2}$ (which is not defined for $\texttt{nu}<2$). Figure \@ref(fig:dinvgamma) plots the probability density functions holding $\texttt{V}$ equal to one but with $\texttt{nu}$ varying.

``` {r label=dinvgamma, echo=FALSE, include=TRUE, fig.cap="Probability density function for a univariate inverse-Wishart with the variance at the limit set to 1 ($\\texttt{V}=1$) and varying degree of belief parameter ($\\texttt{nu}$). With $\\texttt{V}=1$ these distributions are equivalent to inverse gamma distributions with shape and scale parameters set to $\\texttt{nu}$/2."}
xv<-seq(1e-16,5,length=1000)
plot(0, type="n", ylim=c(0,0.45), xlim=c(0,5), xlab=expression(sigma^2), ylab="Density", cex.lab=1.25)
nu<-c(1,0.2,0.02, 0.002)
V<-1
for(i in 1:4){
dv<-dgamma(1/xv, shape=nu[i]/2, rate=(nu[i]*V)/2)/(xv^2)
lines(dv~xv, type="l", col=paste("gray", 100-i*25), lwd=2)
text(xv[which.min(abs(log(dv)-log(0.1*xv))[-1])+1],dv[which.min(abs(log(dv)-log(0.1*xv))[-1])+1], paste("nu=", nu[i]), pos=4, cex=1.5)
}
text(4,0.4, "V=1", cex=1.5)
```

For single variances the inverse-gamma is a special case of the inverse-Wishart[^1.2], and with $\texttt{V}=1$, the shape and scale of the inverse-gamma are both equal to $\texttt{nu}/2$. The inverse-gamma with shape and scale equal to 0.001 used to be commonly used. The motivation behind the prior was that making $\texttt{nu}$ small would result in a less influential prior because is was equivalent to only observing 0.2\% ($\texttt{nu}=0.002$) of a residual *a priori*. Setting $\texttt{nu}=0$ was avoided because this does not define a valid distribution. A probability distribution must integrate to one because a variable must have some value, and this condition is not met when setting $\texttt{nu}=0$. The prior distribution is said to be improper.  In the example here, where $\texttt{V}$ is a single variance, the prior is only proper when $\texttt{V}>0$ and $\texttt{nu}>0$. Although improper priors do not specify valid prior distributions and therefore the Bayesian credentials of any model may be questionable, $\texttt{MCMCglmm}$ does allow them as they have some useful properties. 


### Improper Priors {#IP-sec}

When improper priors are used their are two potential problems that may be encountered. The first is that if the data do not contain enough information, the posterior distribution itself may be improper, and any results obtained from $\texttt{MCMCglmm}$ will be meaningless. In addition, with proper priors there is a zero probability of a variance component being exactly zero but this is not necessarily the case with improper priors. This can produce numerical problems (trying to divide through by zero) and can also result in a reducible chain. A reducible chain is one which gets 'stuck' at some parameter value(s) and cannot escape. This is usually obvious from the `mcmc` plots but $\texttt{MCMCglmm}$ will often terminate before the analysis has finished with an error message of the form:

``` r
ill-conditioned G/R structure: use proper priors ...
```

However, improper priors do have some useful properties and in fact the default prior for the variances in \texttt{MCMCglmm} has $\texttt{nu}=0$ (the value of $\texttt{V}$ is irrelevant). It is tempting to think that this prior is flat for the variance[^1.3], but it is in fact flat for the log-variance and therefore puts more weight on small values than a prior that is flat on the variance (Figure \@ref(fig:Psurface-nu0)) - see Section \@ref(transform-sec). 

``` {r m1a.3}
prior.m1a.3<-list(R=list(V=1, nu=0))
m1a.3<-MCMCglmm(y~1, data=Ndata, thin=1, prior=prior.m1a.3)
```

``` {r label=Psurface-nu0, echo=FALSE, include=TRUE, fig.cap="Likelihood surface for the likelihood $Pr({\\bf y}|\\mu, \\sigma^{2})$ in black, and an MCMC approximation for the posterior distribution $Pr(\\mu, \\sigma^{2} | {\\bf y})$ in red.  The likelihood has been normalised so that the maximum likelihood has a value of one, and the posterior distribution has been normalised so that the posterior mode has a value of one. An almost flat prior was used for the mean $Pr(\\mu)\\sim N(0, 10^8)$ and a flat prior was used for the log-variance $Pr(\\sigma^{2})\\sim IW(\\texttt{V}=1, \\texttt{nu}=0)$)."}
kda.3<-kde2d(m1a.3$Sol, log(m1a.3$VCV), lims=c(-2,2,log(0.1),log(5)), n=50)
kda.3$y<-exp(kda.3$y)
kda.3$z<-sweep(kda.3$z, 2, kda.3$y, "/") # Jacobian of the transform since working on  log-scale
par(mar=c(5, 4.5, 4, 2)+0.1)
contour(mu,sigma2, L/max(L), xlab=expression(mu), ylab=expression(sigma^2), cex.lab=1.25, nlevels=15)
contour(kda.3, add=TRUE, col="red", drawlabels = FALSE)
```

Consequently, the mode of the marginal posterior distribution lies even below the ML estimate \@ref(fig:Pmarg-nu0).

``` {r label=Pmarg-nu0, echo=FALSE, include=TRUE, fig.cap="An MCMC approximation for the marginal posterior distribution of the variance $Pr(\\sigma^{2} | {\\bf y})$.  A non-informative prior specification was used ($Pr(\\mu)\\sim N(0, 10^8)$ and  $Pr(\\sigma^{2})\\sim IW(\\texttt{V}=0, \\texttt{nu}=0)$). The ML and REML estimates are plotted in blue and red,m respectively."}
hist(m1a.3$VCV[which(m1a.3$VCV<5)], breaks=50, main=expression(paste("Posterior Distribution of ",  sigma^2)), xlab=expression(sigma^2))
abline(v=summary(m1a.1)$dispersion, col="red")
abline(v=MLest["var"], col="blue")
```

Although inverse-Wishart distributions with negative degree of belief parameters are not defined, the resulting posterior distribution can be defined and proper if there is sufficient replication.  When $\texttt{V}=0$ and $\texttt{nu}=-1$ we have a flat prior on the standard deviation over the interval $(0,\infty]$. When $\texttt{V}=0$ and $\texttt{nu}=-2$ we have a flat prior on the variance. Since the default prior for the mean is normal with a very large variance ($10^8$) the prior for the mean is also essentially flat, resulting in a prior probability that is proportional to some constant for all possible parameter values. The posterior density in such cases is equal to the likelihood:

$$Pr(\mu, \sigma^{2} | {\bf y}) \propto Pr({\bf y} | \mu, \sigma^{2})
\label{fprior-eq}   (\#eq:fprior-eq)$$

We can overlay the joint posterior distribution on the likelihood surface (Figure \@ref(fig:Psurface-flat)) and see that the two things are in close agreement, up to Monte Carlo error.


``` {r echo=TRUE}
prior.m1a.4<-list(R=list(V=1e-16, nu=-2))
m1a.4<-MCMCglmm(y~1, data=Ndata, thin=1, prior=prior.m1a.4)
```

``` {r label=Psurface-flat, echo=FALSE, include=TRUE, fig.cap="Likelihood surface for the likelihood $Pr({\\bf y}|\\mu, \\sigma^{2})$ in black, and an MCMC approximation for the posterior distribution $Pr(\\mu, \\sigma^{2} | {\\bf y})$ in red.  The likelihood has been normalised so that the maximum likelihood has a value of one, and the posterior distribution has been normalised so that the posterior mode has a value of one. Almost flat priors were used for the mean ($Pr(\\mu)\\sim N(0, 10^8)$ and the variance $Pr(\\sigma^{2})\\sim IW(\\texttt{V}=10^{-16}, \\texttt{nu}=-2)$) and so the posterior distribution is equivalent to the likelihood."}
kda.4<-kde2d(m1a.4$Sol, log(m1a.4$VCV), lims=c(-2,2,log(0.1),log(5)), n=50)
kda.4$y<-exp(kda.4$y)
kda.4$z<-sweep(kda.4$z, 2, kda.4$y, "/") # Jacobian of the transform since working on  log-scale
par(mar=c(5, 4.5, 4, 2)+0.1)
contour(mu,sigma2, L/max(L), xlab=expression(mu), ylab=expression(sigma^2), cex.lab=1.25, nlevels=15)
contour(kda.4, add=TRUE, col="red", drawlabels = FALSE)
```

Here, the joint posterior mode coincides with the ML estimates, as expected (Figure \@ref(fig:Psurface-flat)). In addition, the mode of the marginal distribution for the variance is equivalent to the REML estimator (See Figure \@ref(fig:Pmarg-flat)). Indeed, the REML estimator can be seen as marginalising the mean under a flat prior, and for this reason is sometimes referred to as the marginal likelihood rather than the restricted likelihood (REML).

``` {r label=Pmarg-flat, echo=FALSE, include=TRUE, fig.cap="An MCMC approximation for the marginal posterior distribution of the variance $Pr(\\sigma^{2} | {\\bf y})$.  An almost flat prior specification was used ($Pr(\\mu)\\sim N(0, 10^8)$ and  $Pr(\\sigma^{2})\\sim IW(\\texttt{V}=10^{-16}, \\texttt{nu}=-2)$) and the REML estimator of the variance (red line) coincides with the marginal posterior mode."}
hist(m1a.4$VCV[which(m1a.4$VCV<5)], breaks=50, main=expression(paste("Posterior Distribution of ",  sigma^2)), xlab=expression(sigma^2))
abline(v=summary(m1a.1)$dispersion, col="red")
```

## Transformations {#transform-sec}

Sometimes we would like to know the posterior distribution for some transformation of the parameters. For example, we may wish to obtain the posterior distribution for $\log(\sigma^2)$. With MCMC this is easy - we can just transform the posterior samples (i.e. `log(m1a.2$VCV)`) and treat these as we would any other set of posterior samples. However, it is useful to understand how probabilities are expected to behave under these transformations. The key idea is that the probability of some function of $x$, $f(x)$, is equal to the probability of $x$ divided by the Jacobian. When the transform only involves single parameters the Jacobian is $|df(x)/dx|$ which for the log-transform is $1/x$. For model `m1a.3` we used an inverse-Wishart prior with $\texttt{V=1}$ and $\texttt{nu=0}$. The posterior density is plotted in Figure \@ref(fig:Psurface-nu0) and does not appear to coincide with the likelihood - there is more posterior density at small values of $\sigma^2$

 However, this is because the posterior density is expressed for $\sigma^2$ and the prior is only flat in $log(\sigma^2)$. By multiplying the posterior density for $\sigma^2$ by $\sigma^2$ (i.e. dividing by $1/x$ where $x$ is $\sigma^2$) we would obtain the joint density of $\mu$ and $log(\sigma^2)$. This would reduce the density for small values of $\sigma^2$ and increase the density for large values (since the density is scaled by $\sigma^2$). Indeed, plotting the posterior distribution of $log(\sigma^2)$ shows this effect and the posterior is in agreement with the likelihood, as expected (Figure \@ref(fig:Psurface2-nu0)).

``` {r label=Psurface2-nu0, echo=FALSE, include=TRUE, fig.cap="Likelihood surface for the likelihood $Pr({\\bf y}|\\mu, \\log(\\sigma^{2}))$ in black, and an MCMC approximation for the posterior distribution $Pr(\\mu, \\log(\\sigma^{2}) | {\\bf y})$ in red.  An almost flat prior was used for the mean $Pr(\\mu)\\sim N(0, 10^8)$ and a flat prior was used for the log-variance $Pr(\\sigma^{2})\\sim IW(\\texttt{V}=1, \\texttt{nu}=0)$."}

kda.3<-kde2d(m1a.3$Sol, log(m1a.3$VCV), lims=c(-2,2,log(0.1),log(5)), n=50)
kda.3$y<-exp(kda.3$y)
par(mar=c(5, 5, 4, 2)+0.1)
contour(mu,sigma2, L/max(L), xlab=expression(mu), ylab="", nlevels=15, yaxt = "n")
axis(2, at = 0:5, labels = paste0("log(", 0:5, ")") , las = 1)
title(ylab=expression(log(sigma^2)), line=3.5, cex.lab=1.25)
contour(kda.3, add=TRUE, col="red", drawlabels = FALSE)
```

[^1.1]: The double `t` is because I cannot spell.

[^1.2]: The inverse gamma is a special case of the inverse-Wishart, although it is parametrised using $\texttt{shape}$ and $\texttt{scale}$, where $\texttt{nu}=2\ast\texttt{shape}$ and $\texttt{V} = \frac{\texttt{scale}}{\texttt{shape}}$ (or $\texttt{shape} = \frac{\texttt{nu}}{2}$ and $\texttt{scale} = \texttt{V}\frac{\texttt{nu}}{2}$). There is no density function for the inverse-gamma in base R. However, it can be obtained using the density function for the gamma. Using $\texttt{shape_g}$ and $\texttt{scale_g}$ to designate the shape and scale parameters of a gamma distribution then the density of $\texttt{x}$ under the inverse-gamma is the density of $1/\texttt{x}$ under a gamma distribution with $\texttt{shape_g}=\texttt{shape}$ and $\texttt{scale_g}=1/\texttt{scale}$ multiplied by the Jacobian, $1/\texttt{x}^{2}$. Consequently, we can implement the function `dinvgamma<-function(x, shape, scale, ...){dgamma(1/x, shape=shape, rate=scale, ...)/(x^2)}`. Note $\texttt{rate}=1/\texttt{scale}$

[^1.3]: Embarrassingly, I claimed that $\texttt{V=1}$ and $\texttt{nu=0}$ was flat in the original CourseNotes and I had forgotten to rescale the posterior density by the Jacobian when generating the equivalent contour plot to Figure \@ref(fig:Psurface-nu0) (which is computed on values of $\textrm{log}(\sigma^2)$ for better results, and then transformed).  



